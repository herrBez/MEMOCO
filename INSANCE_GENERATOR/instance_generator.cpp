/**
 * @author Mirko Bez
 * @file instance_generator.cpp
 * 
 * Usage: ./main N <q|r|c> [size]
 */
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <time.h>
#include <sys/time.h>
#include <cmath>
#include <getopt.h>
#include <unistd.h>
#include <stdlib.h>
#include <array>
#include <random>

#include <string>
		
using namespace std;

char buff[256];




/**
 * struct used to simulate points
 */
struct Point{

    double x;
    double y;
	
	
    inline Point& operator=(Point other){
        x=other.x;
        y=other.y;
        return *this;
    }
	/**
	 * print the points
	 */
	void print(){
		cout << "(" << x << "," << y << ")" << endl;
	}
	/**
	 * calculats the euclidean distance between this and other
	 * @param other
	 * @return the manhattan distance between this and other
	 */
	double euclideanDistance(Point other){
		double dx = other.x - x;
		double dy = other.y - y;
		return dx*dx + dy*dy;
	}
	/**
	 * calculates the manhattan distance between this and other
	 * @param other
	 * @return the manhattan distance between this and other
	 */
	double manhattanDistance(Point other){
		double dx = abs(other.x - x);
		double dy = abs(other.y - y);
		return dx + dy;
	}
 };  

/**
 * print the output in gerber file format. 
 * You can view it online on this website http://www.gerber-viewer.com/.
 * @param p the set of drill points
 * @param N the number of drill points
 */
void printGerberFile(Point * p, const int N, const char * filename = "tsp_instance"){
	sprintf(buff, "%s.gbr", filename);
	ofstream outfile(filename);
    /*Format: Leading Zero ommitted, Absolute coordinate, 
     *X:5 digit in the integer part, 
     *Y:5digit in the fractional part 
	 */
	outfile << "%FSLAX52Y52*%" << endl; 
	
	outfile << "%MOMM*%" << endl; //set mm as unit
	outfile << "%TF.FileFunction,Plated,1,8,PTH*%" << endl;
	outfile << "%TF.Part,Single*%" << endl; //single pbc
	outfile << "%LPD*%" << endl; //set polarity to dark
	outfile << "%TA.AperFunction,Other,ComponentDrill*%" << endl; 
	outfile << "%ADD11C,2.000*%" << endl; //size of hole is one mm
	
	outfile << "G01*" << endl;
	outfile << "D11*" << endl;
	
	
	for(int i = 0; i < N; i++){
		sprintf(buff, "X%5.2fY%5.2fD03*", p[i].x, p[i].y); 
		outfile << buff << endl;
	}
	//EOF
	outfile << "M02*" << endl;
}


/**
 * print the cost in a dat file
 * @param cost
 * @param N
 * 
 */
void printDatFile(double * cost, const int N, const char * file_name = "tsp_instance"){
	sprintf(buff, "%s.dat", file_name);
	ofstream outfile(file_name);
	outfile << N << endl;
	for(int i = 0; i < N; i++){
		for(int j  = 0; j < N; j++){
			outfile << cost[i*N + j] << " ";
		}
		outfile << endl;
	}
	outfile.close();
}

bool euclidean = false;

/**
 * calculate the distance between the points and return a (linearized) 2-dimensional array
 * @param N the number of points
 * @param p the points
 * @return an array containing the distances
 */
double * calculateDistance(const int N, Point * p){
	double * cost = new double[N*N];
	for(int i = 0; i < N; i++){
		for(int j = 0; j < N; j++){
			if(i == j){
				cost[i*N + j] = 0;
			}
			
			cost[i*N + j] = euclidean?p[i].euclideanDistance(p[j]):p[i].manhattanDistance(p[j]);
		}
	}
	return cost;
}


/**
 * print the instance in a binary pbm file. The advantage with respect to its ASCII counterpart
 * is that instead of saving 1 or 0 in an (entire byte) it saves 1 or 0 in bits. So it is 8 times
 * smaller than its ASCII counterpart
 * @param size the size of the field
 * @param a the array containing the points to print
 * @param N the number of points
 */
void printBinaryPBM(const int size, Point * a, int N){
	int size_8 = (int) ceil(((double)size)/8) * 8; //approximate to next multiple of eight
	cout << endl << size << size_8 << endl;
	int byte_num = size_8 / 8;
	
	unsigned char * img = new unsigned char[size_8*byte_num];
	
	for(int i = 0; i < size_8*byte_num; i++){
		img[i] = 0;
	}
	for(int i = 0; i < N; i++){
		int index = (int) (rint(a[i].x) * size_8 + rint(a[i].y)); //real index
		
		int byte_id = (int)index/8; // identify the corresponding byte
		cout << "I\t" << index << "\tB\t" << (int)byte_id<< "/" << size_8*byte_num << endl;
		
		int byte_offset = index % 8; //identify the offset from bit 0 to the correct bit
		img[byte_id] |= (128 >> byte_offset);	
	}
	cout << "CIAO";
	ofstream ofs("/tmp/output_bin.pbm");
	ofs << "P4" << endl;
	ofs << "#Image generated by instance_generator - Mirko Bez" << endl;
	ofs << size_8 << " " << size_8 << endl;
	for(int i = 0; i < size_8; i++){
		for(int j = 0; j < byte_num; j++){
			
			printf("%3d", img[i*byte_num+j]);
			ofs << (unsigned char) img[i*byte_num + j];
		}
		cout << endl;
	}
	ofs.close();
	delete[] img;
	exit(EXIT_SUCCESS);
}



/**
 * print the instance generated in a PBM file. 
 * (N.B. It is pure ASCII (it can require several MB with big N values) : possible improvement use the corresponding binary format.
 * @param size the size of the grid (I assume it is squared)
 * @param N the number of points
 */
void printPBM(const int size, Point * a, int N){
	unsigned char * img = new unsigned char[size*size];
	for(int i = 0; i < size*size; i++){
		img[i] = 0;
	}
	for(int i = 0; i < N; i++){
		img[(int) (rint(a[i].x) * size + rint(a[i].y))] = 1;
	}
	
	ofstream ofs("/tmp/output.pbm");
	ofs << "P1" << endl;
	ofs << "#Image generated by instance_generator - Mirko Bez" << endl;
	ofs << size << " " << size << endl;
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			ofs << (char) (img[i*size + j]+48); //48 = '0' in ASCII-code
		}
		ofs << endl;
	}
	ofs.close();
	delete[] img;
}

/**
 * parse the command line input
 * @param opt a char pointer in which the function store the option 
 * 'q' (square), 'r' (random - default), 'c' (circle)
 * @return N the number of points to generate
 */
int get_option(int argc, char * argv[], char * opt){
	stringstream ss;
	int N = 0;
	if(argc < 2){
		cerr << "Usage: " << argv[0] << " N <r|q|c> [size]" << endl;
		exit(EXIT_FAILURE);
	}
	else if(argc < 3){
		ss << argv[1];
		ss >> N;
		*opt = 'r'; //Default is random
	} 
	else if(argc == 3){
		ss << argv[1] << " " << argv[2];
		ss >> N;
		ss >> *opt;
	} else {
		cerr << " Too much arguments given. Exit ... " << endl;
	}
	
	return N;
}


/**
 * generate a random double between the given min and max
 * @param min
 * @param max
 * @return the random generated value
 */
double randomDouble(double min, double max){
	double d = (double) rand() / RAND_MAX;
	return min + d * (max - min);
}


/**
 * generate a random instance
 * @param N the number of points to generate
 * @param size the size of the grid
 * @return an array containing the points
 */
Point * generateRandomInstance(const int N, const int size){
	Point * arr = new Point[N];
	for(int i = 0; i < N; i++){
		arr[i].x = randomDouble(0.0, size);
		arr[i].y = randomDouble(0.0, size);
	}
	return arr;
}

Point * generateCircleInstance(const int N, const int size){
	return NULL;
}


/**
 * generate an instance in which the points are grouped in 4 square very distant from each other
 * @param N the number of points to generate (N should be greater than 4)
 * @param size the size of the square. For simplicity it is a perfect square
 * @return an array containing the generated points
 */
Point * generateSquareInstance(const int N, const int size){
	Point * arr = new Point[N];
	int numOfSquare = 4;
	int numOfPointsPerSquare = N/numOfSquare;
	cout << numOfPointsPerSquare;
	Point * centers = new Point[numOfSquare];
	centers[0].x = size/4;
	centers[0].y = size/4;
	centers[1].x = 3*size/4;
	centers[1].y = size/4;
	centers[2].x = size/4;
	centers[2].y = 3*size/4;
	centers[3].x = 3*size/4;
	centers[3].y = 3*size/4;
	int k = 0;
	for(int i = 0; i < numOfSquare ; i++){
		
		double sizeOfSquare = size/10;
		/*
		 * + represents a point. With 16 we have 5 points per row. 
		 *  + - + - + - + - +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  + - + - + - + - +
		 * 
		 */
		int numOfInnerPointsPerEdge = (numOfPointsPerSquare-4)/4;
		int numOfPointsPerEdge = 2 + numOfInnerPointsPerEdge;
		double step = sizeOfSquare/numOfPointsPerEdge;
		Point pos = centers[i];
		pos.x -= (double) sizeOfSquare/2;
		pos.y += (double) sizeOfSquare/2;
		arr[k++] = pos; //TOP-LEFT POINT
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.x += step;
			arr[k++] = pos;
		} //TILL TOP-RIGHT Point
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.y -= step;
			arr[k++] = pos;
		} //TILL BOTTOM-RIGHT Point
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.x -= step;
			arr[k++] = pos;
		} //TILL BOTTOM-LEFT Point
		for(int j = 0; j < numOfInnerPointsPerEdge; j++){
			pos.y += step;
			arr[k++] = pos;
		} //TILL TOP-LEFT (excluding the topmost-leftmost element that was already added.
	}
	
	delete[] centers;
	return arr;
}


/**
 * Depending on opt it calls the right instance generator method
 * @param N the number of nodes
 * @param opt the option flag, one of 'q'|'r'|'c'
 */
void generateInstance(int N, char opt){
	const int size = 10*N;
	Point * arr;
	double * cost;
	switch(opt){
		case 'r': 
			cout << "genereating random instance" << endl; 
			arr = generateRandomInstance(N, size);
			sprintf(buff, "tsp_instance_%d_%s", N, "random");
			if(N <= 5000) { //otherwise the file will be to big (because for simplicity it is in ASCII format)
				printPBM(size, arr, N);
				printBinaryPBM(size,arr,N);
			}
			printGerberFile(arr, N, buff);
			cost = calculateDistance(N, arr);
			printDatFile(cost, N, buff);
			break;
		case 'q': 
			cout << "generating instance with square/rectangles" << endl;
			arr = generateSquareInstance(N, size);
			sprintf(buff, "tsp_instance_%d_%s", N, "square");

			printPBM(size, arr, N);
			printBinaryPBM(size, arr, N);
			printGerberFile(arr, N, buff);
			cost = calculateDistance(N, arr);
			printDatFile(cost, N,buff);
			
			break;
		//case 'c': cout << "generating instance with circles" << endl; break;
		default: 
			arr = new Point[0];
			cost = new double[0];
	}
	delete[] arr;
	delete[] cost;
}

/**
 * the main function
 * @param argc
 * @param argv
 * @return EXIT_SUCCESS on success
 */
int main(int argc, char * argv[]){
	srand(time(NULL));
	char opt;
	int N = get_option(argc, argv, &opt);
	cout << " N " << N << " OPT " << opt << endl;
	generateInstance(N, opt);
	
	return EXIT_SUCCESS;
}

