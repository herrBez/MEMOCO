/**
 * @author Mirko Bez
 * @file instance_generator.cpp
 * 
 * Usage: ./main N <q|r|c> [size]
 */
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <time.h>
#include <sys/time.h>
#include <cmath>
#include <getopt.h>
#include <unistd.h>
#include <stdlib.h>
#include <array>
#include <random>
		
using namespace std;

/**
 * struct used to simulate points
 */
typedef struct _Point {
	double x;
	double y;
} Point;


/**
 * @TODO 
 */
void printGerber(){
	
}


/**
 * print the instance generated in a PBM file
 * @param size the size of the grid (I assume it is squared)
 * @param N the number of points
 */
void printPBM(const int size, Point * a, int N){
	unsigned char * img = new unsigned char[size*size];
	for(int i = 0; i < size*size; i++){
		img[i] = 0;
	}
	for(int i = 0; i < N; i++){
		img[(int) rint(a[i].x * N + a[i].y)] = 1;
	}
	ofstream ofs("output.pbm");
	ofs << "P1" << endl;
	ofs << "#Image generated by instance_generator - Mirko Bez" << endl;
	ofs << size << " " << size << endl;
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			ofs << (int)img[i*N + j] << " ";
		}
		cout << endl;
		ofs << endl;
	}
	ofs.close();
}

/**
 * parse the command line input
 * @param opt a char pointer in which the function store the option 
 * 'q' (square), 'r' (random - default), 'c' (circle)
 * @return N the number of points to generate
 */
int get_option(int argc, char * argv[], char * opt){
	stringstream ss;
	int N = 0;
	if(argc < 2){
		cerr << "Usage: " << argv[0] << " N <r|q|c> [size]" << endl;
		exit(EXIT_FAILURE);
	}
	else if(argc < 3){
		ss << argv[1];
		ss >> N;
		*opt = 'r'; //Default is random
	} 
	else if(argc == 3){
		ss << argv[1] << " " << argv[2];
		ss >> N;
		ss >> *opt;
	} else {
		cerr << " Too much arguments given. Exit ... " << endl;
	}
	
	return N;
}


/**
 * generate a random double between the given min and max
 * @param min
 * @param max
 * @return the random generated value
 */
double randomDouble(double min, double max){
	double d = (double) rand() / RAND_MAX;
	return min + d * (max - min);
}


/**
 * generate a random instance
 * @param N the number of points to generate
 * @param size the size of the grid
 * @return an array containing the points
 */
Point * generateRandomInstance(const int N, const int size){
	Point * arr = new Point[N];
	for(int i = 0; i < N; i++){
		arr[i].x = randomDouble(0.0, size);
		arr[i].y = randomDouble(0.0, size);
	}
	printPBM(size, arr, N);
	return arr;
}

Point * generateCircleInstance(const int N, const int size){
	return NULL;
}

Point * generateSquareInstance(const int N, const int size){
	Point * arr = new Point[N];
	/*int numOfSquare = 4;
	
	int numOfPointsPerSquare = N/numOfSquare;*/
	
	
	return arr;
}


/**
 * Depending on opt it calls the right instance generator method
 * @param N the number of nodes
 * @param opt the option flag, one of 'q'|'r'|'c'
 */
void generateInstance(int N, char opt){
	const int size = 2*N;
	switch(opt){
		case 'r': 
			cout << "genereating random instance" << endl; 
			generateRandomInstance(N, size);
			break;
		case 'q': cout << "generating instance with square/rectangles" << endl; break;
		case 'c': cout << "generating instance with circles" << endl; break;
	}
}

/**
 * the main function
 * @param argc
 * @param argv
 * @return EXIT_SUCCESS on success
 */
int main(int argc, char * argv[]){
	srand(time(NULL));
	char opt;
	int N = get_option(argc, argv, &opt);
	cout << " N " << N << " OPT " << opt << endl;
	generateInstance(N, opt);
	
	return EXIT_SUCCESS;
}

