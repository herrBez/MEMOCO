/**
 * @author Mirko Bez
 * @file instance_generator.cpp
 * 
 * Usage: ./main N <q|r|c> [size]
 */
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <time.h>
#include <sys/time.h>
#include <cmath>
#include <getopt.h>
#include <unistd.h>
#include <stdlib.h>
#include <array>
#include <random>
		
using namespace std;

/**
 * struct used to simulate points
 */
struct Point{

    double x;
    double y;
	
	
    inline Point& operator=(Point other){
        x=other.x;
        y=other.y;
        return *this;
    }
	/**
	 * print the points
	 */
	void print(){
		cout << "(" << x << "," << y << ")" << endl;
	}
	/**
	 * calculats the euclidean distance between this and other
	 * @param other
	 * @return the manhattan distance between this and other
	 */
	double euclideanDistance(Point other){
		double dx = other.x - x;
		double dy = other.y - y;
		return dx*dx + dy*dy;
	}
	/**
	 * calculates the manhattan distance between this and other
	 * @param other
	 * @return the manhattan distance between this and other
	 */
	double manhattanDistance(Point other){
		double dx = abs(other.x - x);
		double dy = abs(other.y - y);
		return dx + dy;
	}
 };  


/**
 * print the cost in a dat file
 * @param cost
 * @param N
 * 
 */
void printDatFile(double * cost, const int N){
	ofstream outfile("TspInstance.dat");
	outfile << N << endl;
	for(int i = 0; i < N; i++){
		for(int j  = 0; j < N; j++){
			outfile << cost[i*N + j] << " ";
		}
		outfile << endl;
	}
	outfile.close();
}

bool euclidean = false;

/**
 * calculate the distance between the points and return a (linearized) 2-dimensional array
 * @param N the number of points
 * @param p the points
 * @return an array containing the distances
 */
double * calculateDistance(const int N, Point * p){
	double * cost = new double[N*N];
	for(int i = 0; i < N; i++){
		for(int j = 0; j < N; j++){
			if(i == j){
				cost[i*N + j] = 0;
			}
			
			cost[i*N + j] = euclidean?p[i].euclideanDistance(p[j]):p[i].manhattanDistance(p[j]);
		}
	}
	return cost;
}




/**
 * print the instance generated in a PBM file. 
 * (N.B. It is pure ASCII (it can require several MB with big N values) : possible improvement use the corresponding binary format.
 * @param size the size of the grid (I assume it is squared)
 * @param N the number of points
 */
void printPBM(const int size, Point * a, int N){
	unsigned char * img = new unsigned char[size*size];
	for(int i = 0; i < size*size; i++){
		img[i] = 0;
	}
	for(int i = 0; i < N; i++){
		img[(int) (rint(a[i].x) * size + rint(a[i].y))] = 1;
	}
	
	ofstream ofs("output.pbm");
	ofs << "P1" << endl;
	ofs << "#Image generated by instance_generator - Mirko Bez" << endl;
	ofs << size << " " << size << endl;
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			ofs << (int)img[i*size + j] << " ";
		}
		ofs << endl;
	}
	ofs.close();
	delete[] img;
}

/**
 * parse the command line input
 * @param opt a char pointer in which the function store the option 
 * 'q' (square), 'r' (random - default), 'c' (circle)
 * @return N the number of points to generate
 */
int get_option(int argc, char * argv[], char * opt){
	stringstream ss;
	int N = 0;
	if(argc < 2){
		cerr << "Usage: " << argv[0] << " N <r|q|c> [size]" << endl;
		exit(EXIT_FAILURE);
	}
	else if(argc < 3){
		ss << argv[1];
		ss >> N;
		*opt = 'r'; //Default is random
	} 
	else if(argc == 3){
		ss << argv[1] << " " << argv[2];
		ss >> N;
		ss >> *opt;
	} else {
		cerr << " Too much arguments given. Exit ... " << endl;
	}
	
	return N;
}


/**
 * generate a random double between the given min and max
 * @param min
 * @param max
 * @return the random generated value
 */
double randomDouble(double min, double max){
	double d = (double) rand() / RAND_MAX;
	return min + d * (max - min);
}


/**
 * generate a random instance
 * @param N the number of points to generate
 * @param size the size of the grid
 * @return an array containing the points
 */
Point * generateRandomInstance(const int N, const int size){
	Point * arr = new Point[N];
	for(int i = 0; i < N; i++){
		arr[i].x = randomDouble(0.0, size);
		arr[i].y = randomDouble(0.0, size);
	}
	return arr;
}

Point * generateCircleInstance(const int N, const int size){
	return NULL;
}


/**
 * generate an instance in which the points are grouped in 4 square very distant from each other
 * @param N the number of points to generate (N should be greater than 4)
 * @param size the size of the square. For simplicity it is a perfect square
 * @return an array containing the generated points
 */
Point * generateSquareInstance(const int N, const int size){
	Point * arr = new Point[N];
	int numOfSquare = 4;
	int numOfPointsPerSquare = N/numOfSquare;
	cout << numOfPointsPerSquare;
	Point * centers = new Point[numOfSquare];
	centers[0].x = size/4;
	centers[0].y = size/4;
	centers[1].x = 3*size/4;
	centers[1].y = size/4;
	centers[2].x = size/4;
	centers[2].y = 3*size/4;
	centers[3].x = 3*size/4;
	centers[3].y = 3*size/4;
	int k = 0;
	for(int i = 0; i < numOfSquare ; i++){
		
		double sizeOfSquare = size/10;
		/*
		 * + represents a point. With 16 we have 5 points per row. 
		 *  + - + - + - + - +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  +               +
		 *  -               -
		 *  + - + - + - + - +
		 * 
		 */
		int numOfInnerPointsPerEdge = (numOfPointsPerSquare-4)/4;
		int numOfPointsPerEdge = 2 + numOfInnerPointsPerEdge;
		double step = sizeOfSquare/numOfPointsPerEdge;
		Point pos = centers[i];
		pos.x -= (double) sizeOfSquare/2;
		pos.y += (double) sizeOfSquare/2;
		arr[k++] = pos; //TOP-LEFT POINT
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.x += step;
			arr[k++] = pos;
		} //TILL TOP-RIGHT Point
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.y -= step;
			arr[k++] = pos;
		} //TILL BOTTOM-RIGHT Point
		for(int j = 0; j < numOfInnerPointsPerEdge+1; j++){
			pos.x -= step;
			arr[k++] = pos;
		} //TILL BOTTOM-LEFT Point
		for(int j = 0; j < numOfInnerPointsPerEdge; j++){
			pos.y += step;
			arr[k++] = pos;
		} //TILL TOP-LEFT (excluding the topmost-leftmost element that was already added.
	}
	
	delete[] centers;
	return arr;
}


/**
 * Depending on opt it calls the right instance generator method
 * @param N the number of nodes
 * @param opt the option flag, one of 'q'|'r'|'c'
 */
void generateInstance(int N, char opt){
	const int size = 10*N;
	Point * arr;
	double * cost;
	switch(opt){
		case 'r': 
			cout << "genereating random instance" << endl; 
			arr = generateRandomInstance(N, size);
			printPBM(size, arr, N);
			cost = calculateDistance(N, arr);
			printDatFile(cost, N);
			break;
		case 'q': 
			cout << "generating instance with square/rectangles" << endl;
			arr = generateSquareInstance(N, size);
			printPBM(size, arr, N);
			cost = calculateDistance(N, arr);
			printDatFile(cost, N);
			
			break;
		//case 'c': cout << "generating instance with circles" << endl; break;
		default: 
			arr = new Point[0];
			cost = new double[0];
	}
	delete[] arr;
	delete[] cost;
}

/**
 * the main function
 * @param argc
 * @param argv
 * @return EXIT_SUCCESS on success
 */
int main(int argc, char * argv[]){
	srand(time(NULL));
	char opt;
	int N = get_option(argc, argv, &opt);
	cout << " N " << N << " OPT " << opt << endl;
	generateInstance(N, opt);
	
	return EXIT_SUCCESS;
}

